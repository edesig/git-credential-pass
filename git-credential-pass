#!/usr/bin/env sh
# Copyright (C) 2023 Edes Istvan Gergely <edesig@gmail.com>. All Rights Reserved.
# This file is licensed under the MIT License.

readonly VERSION=0.2

# Configuration

readonly DEBUG=${GIT_CREDENTIAL_PASS_DEBUG:-false}
readonly SECRET_PATH=${GIT_CREDENTIAL_SECRET_PATH:-git-credential-pass}

# Helper functions

debug(){
	if test "$DEBUG" != "false"; then
		category="$1"
		shift 1;
		echo "$@" | while read -r line; do
			echo >&2 "git-credential-pass:debug:$category:$line"
		done
	fi
}


get_secret_keys(){
	# Unfortunately pass lists with tree, so
	# this parsing depends on tree's implementation.
	pass ls "$1" | grep '^.── ' | sed 's:^.── ::g'
}

parse(){
	#TODO: current implementation throws out multi valued keys
	debug "parse" "$@"
	path="$1"
	shift 1
	key="$(echo $@ | cut -f1 -d=)"
	value="$(echo $@ | sed 's:[^=]*=\(.*\):\1:g')"
	if echo "$key" | grep -v '\[\]$' -q; then
		echo "$key='$value'"
	fi
}


prepare_input(){
	stdin="$(cat -)"
	debug "raw stdin" "$stdin"
        echo "$stdin" | while read -r line; do
		parse "" $line
	done
}

get_identity(){
        if test -n "username"; then
                echo "$protocol/$username@$host"
        else
                echo "$protocol/$host"
        fi
}


# Commands

get(){
	test -n "$identity" || identity="$(get_identity)"
	test -n "$secrets" || secrets="$(get_secret_keys "$SECRET_PATH/$identity")"
	test -n "$secrets" || exit 1
	for secret in $secrets; do
		echo "$secret=$(pass "$SECRET_PATH/$identity/$secret")";
	done
	for blank in $blanks; do
		echo "${blank}="
	done
}

store(){
	# We don't want implement store to avoid complexity
	# this script is supposed to be an interface between git and pass
	# in order to keep it flexible we let the user to handle pass
	debug "msg" "Not Implemented"
}

erase(){
	# We are not sure yet if it's a good idea to implement it
	debug "msg" "Not Implemented"
}

debug "msg" "debug mode on"
# get inputs
debug "called with" "$@"
stdin=$(prepare_input)
debug "parsed stdin" "$stdin"
eval "$stdin"

# parse the parameters
eval set -- $(getopt -o i:s:b: -l identity: -l secret: -l blank: -- $@)
while true; do
	case "$1" in
		-s|--secret)
			secrets="${secrets:-} $2"
			shift 2
			continue ;;
		-b|--blank)
			blanks="${blanks:-} $2"
			shift 2
			continue ;;
		-i|--identity)
			identity="$2"
			shift 2
			continue ;;
		--)
			shift
			break ;;
	esac
done
command="$1"

"$command"
